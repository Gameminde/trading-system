"""
üí∞ REAL MONEY TRADING SYSTEM - AGENT ENTRA√éNEMENT $100

MISSION: Trading r√©el avec vraies donn√©es de march√© ($100 budget)
OBJECTIF: Entra√Ænement agent avec m√©morisation compl√®te
DONN√âES: 100% R√âELLES (APIs officielles, prix temps r√©el)

üî• ATTENTION: ARGENT R√âEL SIMUL√â - Trait√© comme budget r√©el de $100
"""

import yfinance as yf
import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import json
import os
import time
import logging
from dataclasses import dataclass, asdict
from typing import Dict, List, Optional, Tuple
import threading
from concurrent.futures import ThreadPoolExecutor

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
logger = logging.getLogger("REAL_TRADING")

@dataclass
class RealTradingConfig:
    """Configuration pour trading r√©el"""
    initial_capital: float = 100.0  # $100 R√âEL
    max_positions: int = 5
    max_position_size: float = 0.20  # 20% max par position
    stop_loss: float = 0.05  # 5% stop loss
    take_profit: float = 0.10  # 10% take profit
    trading_fee: float = 0.001  # 0.1% frais
    memory_file: str = "logs/real_trading_memory.json"
    real_data_sources: List[str] = None

    def __post_init__(self):
        if self.real_data_sources is None:
            self.real_data_sources = [
                "yfinance",  # Actions r√©elles
                "binance_api",  # Crypto r√©elles  
                "alpha_vantage",  # Donn√©es fondamentales
                "polygon_api"  # Donn√©es professionnelles
            ]

@dataclass
class RealMarketData:
    """Donn√©es r√©elles de march√©"""
    symbol: str
    price: float
    volume: int
    change_24h: float
    market_cap: Optional[float]
    timestamp: datetime
    source: str
    bid: float
    ask: float
    spread: float

@dataclass
class RealTrade:
    """Trade r√©el avec vraies donn√©es"""
    trade_id: str
    symbol: str
    side: str  # BUY/SELL
    quantity: float
    entry_price: float
    exit_price: Optional[float]
    entry_time: datetime
    exit_time: Optional[datetime]
    pnl: float
    pnl_percent: float
    fees: float
    reason: str  # Raison du trade
    market_data_snapshot: Dict
    agent_confidence: float
    successful: bool

class RealDataProvider:
    """Fournisseur de donn√©es r√©elles"""
    
    def __init__(self):
        self.sources_active = {}
        self._initialize_sources()
        
    def _initialize_sources(self):
        """Initialisation des sources de donn√©es r√©elles"""
        logger.info("üåê Initialisation des sources de donn√©es R√âELLES...")
        
        # YFinance (gratuit, donn√©es r√©elles)
        try:
            # Test avec une action r√©elle
            test = yf.Ticker("AAPL").info
            self.sources_active["yfinance"] = True
            logger.info("‚úÖ YFinance: CONNECT√â (donn√©es actions r√©elles)")
        except Exception as e:
            self.sources_active["yfinance"] = False
            logger.warning(f"‚ö†Ô∏è YFinance: ERREUR {e}")
        
        # Binance API (crypto r√©elles - gratuit)
        try:
            response = requests.get("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT", timeout=5)
            if response.status_code == 200:
                self.sources_active["binance"] = True
                logger.info("‚úÖ Binance API: CONNECT√â (donn√©es crypto r√©elles)")
            else:
                self.sources_active["binance"] = False
        except Exception as e:
            self.sources_active["binance"] = False
            logger.warning(f"‚ö†Ô∏è Binance API: ERREUR {e}")
        
        # CoinGecko API (crypto r√©elles - gratuit)
        try:
            response = requests.get("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd", timeout=5)
            if response.status_code == 200:
                self.sources_active["coingecko"] = True
                logger.info("‚úÖ CoinGecko API: CONNECT√â (donn√©es crypto r√©elles)")
            else:
                self.sources_active["coingecko"] = False
        except Exception as e:
            self.sources_active["coingecko"] = False
            logger.warning(f"‚ö†Ô∏è CoinGecko API: ERREUR {e}")
        
        active_count = sum(self.sources_active.values())
        logger.info(f"üìä SOURCES ACTIVES: {active_count}/3 - Donn√©es 100% R√âELLES disponibles")

    def get_real_stock_price(self, symbol: str) -> Optional[RealMarketData]:
        """Prix r√©el d'une action via YFinance"""
        if not self.sources_active.get("yfinance", False):
            return None
            
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period="1d", interval="1m").tail(1)
            info = ticker.info
            
            if data.empty:
                return None
                
            latest = data.iloc[-1]
            current_price = float(latest['Close'])
            volume = int(latest['Volume'])
            
            # Calcul du spread (estimation)
            spread = current_price * 0.001  # 0.1% spread estim√©
            bid = current_price - spread/2
            ask = current_price + spread/2
            
            # Change 24h
            data_24h = ticker.history(period="2d")
            if len(data_24h) > 1:
                change_24h = ((current_price - float(data_24h.iloc[-2]['Close'])) / float(data_24h.iloc[-2]['Close'])) * 100
            else:
                change_24h = 0.0
                
            return RealMarketData(
                symbol=symbol,
                price=current_price,
                volume=volume,
                change_24h=change_24h,
                market_cap=info.get('marketCap', 0),
                timestamp=datetime.now(),
                source="YFinance",
                bid=bid,
                ask=ask,
                spread=spread
            )
            
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration {symbol}: {e}")
            return None
    
    def get_real_crypto_price(self, symbol: str) -> Optional[RealMarketData]:
        """Prix r√©el crypto via Binance API"""
        if not self.sources_active.get("binance", False):
            return None
            
        try:
            # Prix actuel
            price_url = f"https://api.binance.com/api/v3/ticker/price?symbol={symbol}USDT"
            response = requests.get(price_url, timeout=5)
            
            if response.status_code != 200:
                return None
                
            price_data = response.json()
            current_price = float(price_data['price'])
            
            # Stats 24h
            stats_url = f"https://api.binance.com/api/v3/ticker/24hr?symbol={symbol}USDT"
            stats_response = requests.get(stats_url, timeout=5)
            
            if stats_response.status_code == 200:
                stats = stats_response.json()
                volume = int(float(stats['volume']))
                change_24h = float(stats['priceChangePercent'])
            else:
                volume = 0
                change_24h = 0.0
            
            # OrderBook pour spread r√©el
            book_url = f"https://api.binance.com/api/v3/depth?symbol={symbol}USDT&limit=5"
            book_response = requests.get(book_url, timeout=5)
            
            if book_response.status_code == 200:
                book = book_response.json()
                if book['bids'] and book['asks']:
                    bid = float(book['bids'][0][0])
                    ask = float(book['asks'][0][0])
                    spread = ask - bid
                else:
                    bid = current_price * 0.999
                    ask = current_price * 1.001
                    spread = ask - bid
            else:
                bid = current_price * 0.999
                ask = current_price * 1.001  
                spread = ask - bid
                
            return RealMarketData(
                symbol=symbol,
                price=current_price,
                volume=volume,
                change_24h=change_24h,
                market_cap=None,  # Non disponible via Binance
                timestamp=datetime.now(),
                source="Binance",
                bid=bid,
                ask=ask,
                spread=spread
            )
            
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration crypto {symbol}: {e}")
            return None

class RealTradingMemory:
    """Syst√®me de m√©moire pour entra√Ænement agent"""
    
    def __init__(self, memory_file: str):
        self.memory_file = memory_file
        self.memory = {
            "trades": [],
            "market_data_history": [],
            "decisions": [],
            "performance": [],
            "learning_patterns": [],
            "errors": [],
            "successful_strategies": []
        }
        self._load_memory()
        logger.info(f"üß† M√©moire agent initialis√©e: {memory_file}")
    
    def _load_memory(self):
        """Charger la m√©moire existante"""
        if os.path.exists(self.memory_file):
            try:
                with open(self.memory_file, 'r', encoding='utf-8') as f:
                    saved_memory = json.load(f)
                    self.memory.update(saved_memory)
                logger.info(f"üìö M√©moire charg√©e: {len(self.memory['trades'])} trades historiques")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur chargement m√©moire: {e}")
    
    def save_memory(self):
        """Sauvegarder la m√©moire"""
        try:
            os.makedirs(os.path.dirname(self.memory_file), exist_ok=True)
            
            # Convertir les objets datetime en strings pour JSON
            memory_copy = {}
            for key, value in self.memory.items():
                if isinstance(value, list):
                    memory_copy[key] = []
                    for item in value:
                        if isinstance(item, dict):
                            item_copy = {}
                            for k, v in item.items():
                                if isinstance(v, datetime):
                                    item_copy[k] = v.isoformat()
                                else:
                                    item_copy[k] = v
                            memory_copy[key].append(item_copy)
                        else:
                            memory_copy[key].append(item)
                else:
                    memory_copy[key] = value
            
            with open(self.memory_file, 'w', encoding='utf-8') as f:
                json.dump(memory_copy, f, indent=2, ensure_ascii=False)
            logger.info("üíæ M√©moire sauvegard√©e avec succ√®s")
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde m√©moire: {e}")
    
    def remember_trade(self, trade: RealTrade):
        """M√©moriser un trade"""
        trade_dict = asdict(trade)
        # Convertir datetime en string
        for key, value in trade_dict.items():
            if isinstance(value, datetime):
                trade_dict[key] = value.isoformat()
        
        self.memory["trades"].append(trade_dict)
        logger.info(f"üß† Trade m√©moris√©: {trade.symbol} {trade.side} ${trade.pnl:.2f}")
    
    def remember_decision(self, symbol: str, action: str, reasoning: str, confidence: float, market_data: RealMarketData):
        """M√©moriser une d√©cision de trading"""
        decision = {
            "timestamp": datetime.now().isoformat(),
            "symbol": symbol,
            "action": action,
            "reasoning": reasoning,
            "confidence": confidence,
            "market_price": market_data.price,
            "market_change_24h": market_data.change_24h,
            "market_volume": market_data.volume,
            "spread": market_data.spread,
            "source": market_data.source
        }
        self.memory["decisions"].append(decision)
        logger.info(f"ü§î D√©cision m√©moris√©e: {symbol} {action} (confiance: {confidence:.1%})")
    
    def remember_market_data(self, data: RealMarketData):
        """M√©moriser les donn√©es de march√©"""
        market_record = {
            "timestamp": data.timestamp.isoformat(),
            "symbol": data.symbol,
            "price": data.price,
            "volume": data.volume,
            "change_24h": data.change_24h,
            "spread": data.spread,
            "source": data.source
        }
        self.memory["market_data_history"].append(market_record)
    
    def get_learning_insights(self) -> Dict:
        """Analyser la m√©moire pour insights d'apprentissage"""
        if not self.memory["trades"]:
            return {"message": "Aucun trade pour analyse"}
        
        total_trades = len(self.memory["trades"])
        profitable_trades = sum(1 for t in self.memory["trades"] if float(t.get("pnl", 0)) > 0)
        win_rate = profitable_trades / total_trades if total_trades > 0 else 0
        
        total_pnl = sum(float(t.get("pnl", 0)) for t in self.memory["trades"])
        
        # Patterns de succ√®s
        successful_symbols = {}
        for trade in self.memory["trades"]:
            if float(trade.get("pnl", 0)) > 0:
                symbol = trade.get("symbol", "")
                successful_symbols[symbol] = successful_symbols.get(symbol, 0) + 1
        
        insights = {
            "total_trades": total_trades,
            "win_rate": win_rate,
            "total_pnl": total_pnl,
            "profitable_trades": profitable_trades,
            "successful_symbols": successful_symbols,
            "average_pnl": total_pnl / total_trades if total_trades > 0 else 0
        }
        
        return insights

class RealMoneyTradingAgent:
    """Agent de trading avec argent r√©el ($100 budget)"""
    
    def __init__(self, config: RealTradingConfig):
        self.config = config
        self.data_provider = RealDataProvider()
        self.memory = RealTradingMemory(config.memory_file)
        
        # Portfolio r√©el
        self.cash = config.initial_capital  # $100 R√âEL
        self.positions = {}  # {symbol: {"quantity": float, "avg_price": float}}
        self.total_fees_paid = 0.0
        
        # Historique performance
        self.portfolio_history = []
        self.trade_history = []
        
        logger.info("üí∞ REAL MONEY TRADING AGENT INITIALIS√â")
        logger.info(f"   Budget initial: ${self.cash:.2f} (TRAIT√â COMME R√âEL)")
        logger.info(f"   Sources donn√©es: {sum(self.data_provider.sources_active.values())}/3 actives")
        logger.info(f"   M√©moire: {len(self.memory.memory['trades'])} trades historiques")
    
    def get_portfolio_value(self) -> float:
        """Valeur totale du portfolio en temps r√©el"""
        total_value = self.cash
        
        for symbol, position in self.positions.items():
            # R√©cup√©ration prix r√©el actuel
            if symbol in ["BTC", "ETH", "BNB"]:  # Crypto
                market_data = self.data_provider.get_real_crypto_price(symbol)
            else:  # Actions
                market_data = self.data_provider.get_real_stock_price(symbol)
            
            if market_data:
                position_value = position["quantity"] * market_data.price
                total_value += position_value
        
        return total_value
    
    def calculate_position_size(self, symbol: str, confidence: float) -> float:
        """Calcul taille position bas√©e sur confiance et risk management"""
        base_size = min(self.config.max_position_size, confidence * 0.3)  # Max 30% si confiance 100%
        max_dollar_amount = self.cash * base_size
        
        return max_dollar_amount
    
    def execute_real_buy(self, symbol: str, market_data: RealMarketData, reasoning: str, confidence: float) -> Optional[RealTrade]:
        """Ex√©cution BUY avec vraies donn√©es"""
        
        # Calcul taille position
        position_size_dollars = self.calculate_position_size(symbol, confidence)
        
        if position_size_dollars < 1.0:  # Minimum $1
            logger.warning(f"‚ö†Ô∏è Position trop petite pour {symbol}: ${position_size_dollars:.2f}")
            return None
        
        if position_size_dollars > self.cash:
            position_size_dollars = self.cash * 0.95  # Garde 5% de cash
        
        # Prix d'ex√©cution (ask price pour buy)
        execution_price = market_data.ask
        quantity = position_size_dollars / execution_price
        
        # Frais de transaction
        fees = position_size_dollars * self.config.trading_fee
        total_cost = position_size_dollars + fees
        
        if total_cost > self.cash:
            logger.warning(f"‚ö†Ô∏è Fonds insuffisants pour {symbol}: ${total_cost:.2f} > ${self.cash:.2f}")
            return None
        
        # Ex√©cution du trade
        trade_id = f"{symbol}_BUY_{int(datetime.now().timestamp())}"
        
        # Mise √† jour portfolio
        self.cash -= total_cost
        self.total_fees_paid += fees
        
        if symbol in self.positions:
            # Moyenne des prix
            old_qty = self.positions[symbol]["quantity"]
            old_avg = self.positions[symbol]["avg_price"]
            new_avg = ((old_qty * old_avg) + (quantity * execution_price)) / (old_qty + quantity)
            
            self.positions[symbol]["quantity"] += quantity
            self.positions[symbol]["avg_price"] = new_avg
        else:
            self.positions[symbol] = {"quantity": quantity, "avg_price": execution_price}
        
        # Cr√©ation du trade
        trade = RealTrade(
            trade_id=trade_id,
            symbol=symbol,
            side="BUY",
            quantity=quantity,
            entry_price=execution_price,
            exit_price=None,
            entry_time=datetime.now(),
            exit_time=None,
            pnl=0.0,  # PnL calcul√© √† la vente
            pnl_percent=0.0,
            fees=fees,
            reason=reasoning,
            market_data_snapshot={
                "price": market_data.price,
                "bid": market_data.bid,
                "ask": market_data.ask,
                "spread": market_data.spread,
                "volume": market_data.volume,
                "change_24h": market_data.change_24h,
                "source": market_data.source
            },
            agent_confidence=confidence,
            successful=True  # Sera mis √† jour lors de la vente
        )
        
        # M√©morisation
        self.memory.remember_trade(trade)
        self.memory.remember_decision(symbol, "BUY", reasoning, confidence, market_data)
        self.trade_history.append(trade)
        
        logger.info(f"üü¢ BUY EX√âCUT√â: {symbol}")
        logger.info(f"   Quantit√©: {quantity:.6f}")
        logger.info(f"   Prix: ${execution_price:.4f}")
        logger.info(f"   Co√ªt total: ${total_cost:.2f}")
        logger.info(f"   Cash restant: ${self.cash:.2f}")
        
        return trade
    
    def execute_real_sell(self, symbol: str, market_data: RealMarketData, reasoning: str, confidence: float) -> Optional[RealTrade]:
        """Ex√©cution SELL avec vraies donn√©es"""
        
        if symbol not in self.positions:
            logger.warning(f"‚ö†Ô∏è Aucune position √† vendre pour {symbol}")
            return None
        
        position = self.positions[symbol]
        quantity = position["quantity"]
        avg_buy_price = position["avg_price"]
        
        # Prix d'ex√©cution (bid price pour sell)
        execution_price = market_data.bid
        gross_proceeds = quantity * execution_price
        
        # Frais de transaction
        fees = gross_proceeds * self.config.trading_fee
        net_proceeds = gross_proceeds - fees
        
        # Calcul P&L
        total_cost = quantity * avg_buy_price
        pnl = net_proceeds - total_cost
        pnl_percent = (pnl / total_cost) * 100 if total_cost > 0 else 0
        
        # Ex√©cution du trade
        trade_id = f"{symbol}_SELL_{int(datetime.now().timestamp())}"
        
        # Mise √† jour portfolio
        self.cash += net_proceeds
        self.total_fees_paid += fees
        del self.positions[symbol]  # Position ferm√©e
        
        # Cr√©ation du trade
        trade = RealTrade(
            trade_id=trade_id,
            symbol=symbol,
            side="SELL",
            quantity=quantity,
            entry_price=avg_buy_price,
            exit_price=execution_price,
            entry_time=datetime.now(),  # Approximation
            exit_time=datetime.now(),
            pnl=pnl,
            pnl_percent=pnl_percent,
            fees=fees,
            reason=reasoning,
            market_data_snapshot={
                "price": market_data.price,
                "bid": market_data.bid,
                "ask": market_data.ask,
                "spread": market_data.spread,
                "volume": market_data.volume,
                "change_24h": market_data.change_24h,
                "source": market_data.source
            },
            agent_confidence=confidence,
            successful=(pnl > 0)
        )
        
        # M√©morisation
        self.memory.remember_trade(trade)
        self.memory.remember_decision(symbol, "SELL", reasoning, confidence, market_data)
        self.trade_history.append(trade)
        
        result_emoji = "üü¢" if pnl > 0 else "üî¥"
        logger.info(f"{result_emoji} SELL EX√âCUT√â: {symbol}")
        logger.info(f"   Quantit√©: {quantity:.6f}")
        logger.info(f"   Prix achat: ${avg_buy_price:.4f}")
        logger.info(f"   Prix vente: ${execution_price:.4f}")
        logger.info(f"   P&L: ${pnl:.2f} ({pnl_percent:.1f}%)")
        logger.info(f"   Cash total: ${self.cash:.2f}")
        
        return trade
    
    def analyze_market_sentiment(self, symbol: str, market_data: RealMarketData) -> Tuple[str, float, str]:
        """Analyse sentiment bas√©e sur vraies donn√©es"""
        
        # Analyse technique simple mais r√©elle
        reasoning_factors = []
        score = 0.5  # Neutre par d√©faut
        
        # Volume analysis
        if market_data.volume > 0:
            if market_data.volume > 1000000:  # Volume √©lev√©
                if market_data.change_24h > 0:
                    score += 0.1
                    reasoning_factors.append(f"Volume √©lev√© ({market_data.volume:,}) + hausse")
                else:
                    score -= 0.1
                    reasoning_factors.append(f"Volume √©lev√© ({market_data.volume:,}) + baisse")
        
        # Price momentum
        if market_data.change_24h > 5:
            score += 0.2
            reasoning_factors.append(f"Forte hausse 24h: +{market_data.change_24h:.1f}%")
        elif market_data.change_24h < -5:
            score -= 0.2
            reasoning_factors.append(f"Forte baisse 24h: {market_data.change_24h:.1f}%")
        elif market_data.change_24h > 1:
            score += 0.1
            reasoning_factors.append(f"Hausse mod√©r√©e 24h: +{market_data.change_24h:.1f}%")
        elif market_data.change_24h < -1:
            score -= 0.1
            reasoning_factors.append(f"Baisse mod√©r√©e 24h: {market_data.change_24h:.1f}%")
        
        # Spread analysis
        spread_percent = (market_data.spread / market_data.price) * 100
        if spread_percent < 0.1:
            score += 0.05
            reasoning_factors.append("Spread faible (liquidit√© √©lev√©e)")
        elif spread_percent > 1.0:
            score -= 0.1
            reasoning_factors.append("Spread √©lev√© (faible liquidit√©)")
        
        # D√©termination action
        if score >= 0.65:
            action = "BUY"
        elif score <= 0.35:
            action = "SELL"
        else:
            action = "HOLD"
        
        confidence = abs(score - 0.5) * 2  # Convertir en confiance 0-1
        reasoning = " | ".join(reasoning_factors) if reasoning_factors else "Analyse neutre"
        
        return action, confidence, reasoning
    
    def run_trading_session(self, symbols: List[str], duration_minutes: int = 60):
        """Session de trading r√©el"""
        logger.info("üöÄ D√âBUT SESSION DE TRADING R√âEL")
        logger.info(f"   Symboles: {symbols}")
        logger.info(f"   Dur√©e: {duration_minutes} minutes")
        logger.info(f"   Budget initial: ${self.config.initial_capital:.2f}")
        
        start_time = datetime.now()
        end_time = start_time + timedelta(minutes=duration_minutes)
        
        session_trades = 0
        
        try:
            while datetime.now() < end_time:
                # Analyse de chaque symbole
                for symbol in symbols:
                    try:
                        # R√©cup√©ration donn√©es r√©elles
                        if symbol in ["BTC", "ETH", "BNB", "ADA", "DOT"]:
                            market_data = self.data_provider.get_real_crypto_price(symbol)
                        else:
                            market_data = self.data_provider.get_real_stock_price(symbol)
                        
                        if not market_data:
                            logger.warning(f"‚ö†Ô∏è Pas de donn√©es pour {symbol}")
                            continue
                        
                        # M√©morisation donn√©es march√©
                        self.memory.remember_market_data(market_data)
                        
                        # Analyse sentiment
                        action, confidence, reasoning = self.analyze_market_sentiment(symbol, market_data)
                        
                        logger.info(f"üìä {symbol}: {action} (confiance: {confidence:.1%}) - {reasoning}")
                        
                        # Ex√©cution selon action (seuil abaiss√© pour plus d'activit√©)
                        if action == "BUY" and confidence > 0.25 and len(self.positions) < self.config.max_positions:
                            trade = self.execute_real_buy(symbol, market_data, reasoning, confidence)
                            if trade:
                                session_trades += 1
                        
                        elif action == "SELL" and symbol in self.positions and confidence > 0.25:
                            trade = self.execute_real_sell(symbol, market_data, reasoning, confidence)
                            if trade:
                                session_trades += 1
                        
                        # Portfolio status
                        portfolio_value = self.get_portfolio_value()
                        self.portfolio_history.append({
                            "timestamp": datetime.now(),
                            "portfolio_value": portfolio_value,
                            "cash": self.cash,
                            "positions_count": len(self.positions)
                        })
                        
                        # Affichage status
                        if session_trades > 0 and session_trades % 5 == 0:
                            logger.info(f"üíº Portfolio: ${portfolio_value:.2f} | Cash: ${self.cash:.2f} | Positions: {len(self.positions)}")
                        
                        time.sleep(10)  # Pause entre analyses
                        
                    except Exception as e:
                        logger.error(f"‚ùå Erreur analyse {symbol}: {e}")
                        continue
                
                time.sleep(30)  # Pause entre cycles
                
        except KeyboardInterrupt:
            logger.info("üõë Session interrompue par utilisateur")
        
        # Fin de session
        final_portfolio_value = self.get_portfolio_value()
        total_return = final_portfolio_value - self.config.initial_capital
        return_percent = (total_return / self.config.initial_capital) * 100
        
        logger.info("üèÅ FIN SESSION DE TRADING")
        logger.info(f"   Trades ex√©cut√©s: {session_trades}")
        logger.info(f"   Portfolio final: ${final_portfolio_value:.2f}")
        logger.info(f"   Return total: ${total_return:.2f} ({return_percent:.1f}%)")
        logger.info(f"   Frais pay√©s: ${self.total_fees_paid:.2f}")
        logger.info(f"   Positions ouvertes: {len(self.positions)}")
        
        # Sauvegarde m√©moire
        self.memory.save_memory()
        
        return {
            "session_trades": session_trades,
            "final_portfolio_value": final_portfolio_value,
            "total_return": total_return,
            "return_percent": return_percent,
            "total_fees": self.total_fees_paid,
            "positions_count": len(self.positions)
        }

def main():
    """Fonction principale - Trading r√©el $100"""
    
    print("üí∞" + "="*80 + "üí∞")
    print("   üî• REAL MONEY TRADING SYSTEM - $100 BUDGET R√âEL")
    print("="*84)
    print("   MISSION: Trading avec vraies donn√©es de march√©")
    print("   BUDGET: $100 (trait√© comme argent r√©el)")
    print("   DONN√âES: 100% r√©elles via APIs officielles")
    print("   M√âMOIRE: Entra√Ænement agent complet")
    print("üí∞" + "="*80 + "üí∞")
    
    # Configuration
    config = RealTradingConfig()
    
    # Agent de trading
    agent = RealMoneyTradingAgent(config)
    
    # Symboles pour trading
    trading_symbols = [
        # Actions principales
        "AAPL", "MSFT", "GOOGL", "AMZN", "TSLA",
        # Crypto principales  
        "BTC", "ETH", "BNB"
    ]
    
    print(f"\nüéØ CONFIGURATION DE TRADING:")
    print(f"   Budget initial: ${config.initial_capital:.2f}")
    print(f"   Max positions: {config.max_positions}")
    print(f"   Max position size: {config.max_position_size:.1%}")
    print(f"   Stop loss: {config.stop_loss:.1%}")
    print(f"   Frais: {config.trading_fee:.1%}")
    print(f"   Symboles: {', '.join(trading_symbols)}")
    
    print(f"\nüìä SOURCES DE DONN√âES:")
    for source, active in agent.data_provider.sources_active.items():
        status = "‚úÖ ACTIF" if active else "‚ùå INACTIF"
        print(f"   {source}: {status}")
    
    # Insights m√©moire existante
    insights = agent.memory.get_learning_insights()
    if insights.get("total_trades", 0) > 0:
        print(f"\nüß† M√âMOIRE EXISTANTE:")
        print(f"   Trades historiques: {insights['total_trades']}")
        print(f"   Win rate: {insights['win_rate']:.1%}")
        print(f"   P&L total: ${insights['total_pnl']:.2f}")
        print(f"   P&L moyen: ${insights['average_pnl']:.2f}")
    
    print(f"\nüöÄ D√âMARRAGE SESSION DE TRADING...")
    input("   Appuyez sur Entr√©e pour commencer (Ctrl+C pour arr√™ter)...")
    
    # Lancement session de trading
    try:
        results = agent.run_trading_session(
            symbols=trading_symbols,
            duration_minutes=30  # 30 minutes de trading
        )
        
        print(f"\nüèÜ R√âSULTATS SESSION:")
        print(f"   Trades: {results['session_trades']}")
        print(f"   Portfolio final: ${results['final_portfolio_value']:.2f}")
        print(f"   Return: ${results['total_return']:.2f} ({results['return_percent']:.1f}%)")
        print(f"   Frais: ${results['total_fees']:.2f}")
        print(f"   Positions: {results['positions_count']}")
        
        # Analyse apprentissage
        final_insights = agent.memory.get_learning_insights()
        print(f"\nüß† APPRENTISSAGE AGENT:")
        if final_insights.get('total_trades', 0) > 0:
            print(f"   Win rate global: {final_insights['win_rate']:.1%}")
            print(f"   Symboles r√©ussis: {final_insights.get('successful_symbols', {})}")
        else:
            print(f"   Aucun trade ex√©cut√© - Agent trop prudent")
        
    except KeyboardInterrupt:
        print("\nüõë Session interrompue")
    except Exception as e:
        print(f"\n‚ùå Erreur session: {e}")
    
    print("\nüíæ M√©moire sauvegard√©e pour entra√Ænement futur")
    print("üéì Agent pr√™t pour prochaine session")

if __name__ == "__main__":
    main()
