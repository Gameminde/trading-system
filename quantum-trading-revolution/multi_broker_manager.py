"""
üöÄ MULTI-BROKER MANAGER - DIVERSIFICATION G√âOGRAPHIQUE
‚úÖ Interactive Brokers + Alpaca + Yahoo Finance
üéØ Objectif: +15-25% diversification et meilleurs prix
"""

import yfinance as yf
import logging
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import warnings
warnings.filterwarnings('ignore')

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
logger = logging.getLogger("MULTI_BROKER_MANAGER")

class YahooBroker:
    """Broker Yahoo Finance (gratuit, donn√©es temps r√©el)"""
    
    def __init__(self):
        self.name = "Yahoo Finance"
        self.connected = True
        self.rate_limit = 100  # Appels par minute
        self.last_call = 0
        
    def connect(self):
        """Yahoo Finance est toujours connect√©"""
        self.connected = True
        logger.info(f"‚úÖ {self.name} connect√©")
        
    def get_current_price(self, symbol: str) -> Optional[float]:
        """R√©cup√©rer le prix actuel"""
        try:
            # Rate limiting
            current_time = time.time()
            if current_time - self.last_call < 60 / self.rate_limit:
                time.sleep(60 / self.rate_limit)
            
            ticker = yf.Ticker(symbol)
            price = ticker.info.get('regularMarketPrice')
            self.last_call = current_time
            
            if price:
                logger.info(f"üìä {self.name} - {symbol}: ${price:.2f}")
                return float(price)
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Pas de prix pour {symbol}")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå {self.name} - Erreur prix {symbol}: {e}")
            return None
    
    def execute_trade(self, symbol: str, action: str, quantity: int) -> bool:
        """Simuler l'ex√©cution d'un trade (Yahoo = lecture seule)"""
        logger.info(f"üìù {self.name} - Simulation {action} {quantity} {symbol}")
        return True  # Simulation r√©ussie

class IBBroker:
    """Broker Interactive Brokers (connexion locale)"""
    
    def __init__(self):
        self.name = "Interactive Brokers"
        self.connected = False
        self.ib = None
        
    def connect(self):
        """Connecter √† Interactive Brokers"""
        try:
            # V√©rifier si IB Gateway est disponible
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            result = sock.connect_ex(('127.0.0.1', 7497))
            sock.close()
            
            if result == 0:
                # Port ouvert - essayer de se connecter
                try:
                    from ib_insync import IB, Stock, MarketOrder
                    self.ib = IB()
                    self.ib.connect('127.0.0.1', 7497, clientId=1, timeout=5)
                    self.connected = True
                    logger.info(f"‚úÖ {self.name} connect√© via IB Gateway")
                except ImportError:
                    logger.warning(f"‚ö†Ô∏è {self.name} - ib_insync non install√©")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {self.name} - Connexion √©chou√©e: {e}")
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Port 7497 ferm√© (IB Gateway non d√©marr√©)")
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è {self.name} - Erreur connexion: {e}")
    
    def get_current_price(self, symbol: str) -> Optional[float]:
        """R√©cup√©rer le prix actuel via IB"""
        if not self.connected or not self.ib:
            return None
            
        try:
            stock = Stock(symbol, 'SMART', 'USD')
            ticker = self.ib.reqMktData(stock, '', False, False)
            self.ib.sleep(1)  # Attendre les donn√©es
            
            if ticker.marketPrice():
                logger.info(f"üìä {self.name} - {symbol}: ${ticker.marketPrice():.2f}")
                return ticker.marketPrice()
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Pas de prix IB pour {symbol}")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå {self.name} - Erreur prix {symbol}: {e}")
            return None
    
    def execute_trade(self, symbol: str, action: str, quantity: int) -> bool:
        """Ex√©cuter un trade via IB"""
        if not self.connected or not self.ib:
            logger.warning(f"‚ö†Ô∏è {self.name} - Non connect√©")
            return False
            
        try:
            stock = Stock(symbol, 'SMART', 'USD')
            order = MarketOrder(action.upper(), quantity)
            trade = self.ib.placeOrder(stock, order)
            
            # Attendre la confirmation
            self.ib.sleep(2)
            
            if trade.orderStatus.status == 'Filled':
                logger.info(f"üü¢ {self.name} - {action} {quantity} {symbol} ex√©cut√©")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Trade non ex√©cut√©: {trade.orderStatus.status}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå {self.name} - Erreur trade {symbol}: {e}")
            return False

class AlpacaBroker:
    """Broker Alpaca (paper trading)"""
    
    def __init__(self):
        self.name = "Alpaca"
        self.connected = False
        self.api = None
        
        # Configuration par d√©faut (√† remplacer par vos cl√©s)
        self.api_key = "YOUR_ALPACA_KEY"
        self.secret_key = "YOUR_ALPACA_SECRET"
        self.base_url = "https://paper-api.alpaca.markets"
        
    def connect(self):
        """Connecter √† Alpaca"""
        try:
            import alpaca_trade_api as tradeapi
            
            # V√©rifier si les cl√©s sont configur√©es
            if self.api_key == "YOUR_ALPACA_KEY":
                logger.warning(f"‚ö†Ô∏è {self.name} - Cl√©s API non configur√©es")
                return
            
            self.api = tradeapi.REST(
                self.api_key,
                self.secret_key,
                base_url=self.base_url
            )
            
            # V√©rifier la connexion
            account = self.api.get_account()
            if account.status == 'ACTIVE':
                self.connected = True
                logger.info(f"‚úÖ {self.name} connect√© - Compte: {account.status}")
                logger.info(f"   Balance: ${float(account.cash):,.2f}")
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Compte non actif: {account.status}")
                
        except ImportError:
            logger.warning(f"‚ö†Ô∏è {self.name} - alpaca_trade_api non install√©")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è {self.name} - Erreur connexion: {e}")
    
    def get_current_price(self, symbol: str) -> Optional[float]:
        """R√©cup√©rer le prix actuel via Alpaca"""
        if not self.connected or not self.api:
            return None
            
        try:
            barset = self.api.get_barset(symbol, 'minute', limit=1)
            if symbol in barset and len(barset[symbol]) > 0:
                price = barset[symbol][0].c
                logger.info(f"üìä {self.name} - {symbol}: ${price:.2f}")
                return price
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Pas de donn√©es pour {symbol}")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå {self.name} - Erreur prix {symbol}: {e}")
            return None
    
    def execute_trade(self, symbol: str, action: str, quantity: int) -> bool:
        """Ex√©cuter un trade via Alpaca"""
        if not self.connected or not self.api:
            logger.warning(f"‚ö†Ô∏è {self.name} - Non connect√©")
            return False
            
        try:
            order = self.api.submit_order(
                symbol=symbol,
                qty=quantity,
                side=action.lower(),
                type='market',
                time_in_force='gtc'
            )
            
            # Attendre la confirmation
            time.sleep(2)
            
            if order.status in ['filled', 'partially_filled']:
                logger.info(f"üü¢ {self.name} - {action} {quantity} {symbol} ex√©cut√©")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è {self.name} - Trade non ex√©cut√©: {order.status}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå {self.name} - Erreur trade {symbol}: {e}")
            return False

class MultiBrokerManager:
    """Gestionnaire multi-broker pour diversification"""
    
    def __init__(self):
        self.brokers = {
            'yahoo': YahooBroker(),
            'interactive_brokers': IBBroker(),
            'alpaca': AlpacaBroker()
        }
        self.active_broker = 'yahoo'  # Par d√©faut
        self.connection_status = {}
        
        logger.info("üöÄ Multi-Broker Manager initialis√©")
        logger.info(f"   Brokers: {list(self.brokers.keys())}")
    
    def connect_brokers(self):
        """Connecter tous les brokers disponibles"""
        logger.info("üîå Connexion aux brokers...")
        
        for name, broker in self.brokers.items():
            try:
                broker.connect()
                self.connection_status[name] = broker.connected
                
                if broker.connected:
                    logger.info(f"‚úÖ {name} connect√©")
                else:
                    logger.warning(f"‚ö†Ô∏è {name} non disponible")
                    
            except Exception as e:
                logger.error(f"‚ùå Erreur connexion {name}: {e}")
                self.connection_status[name] = False
        
        # Afficher le statut
        connected_count = sum(self.connection_status.values())
        logger.info(f"üìä Statut connexion: {connected_count}/{len(self.brokers)} brokers connect√©s")
    
    def get_best_price(self, symbol: str) -> Tuple[Optional[str], Optional[float]]:
        """Comparer prix entre brokers et retourner le meilleur"""
        prices = {}
        
        for name, broker in self.brokers.items():
            if self.connection_status.get(name, False):
                try:
                    price = broker.get_current_price(symbol)
                    if price and price > 0:
                        prices[name] = price
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Erreur prix {name} pour {symbol}: {e}")
                    continue
        
        if not prices:
            logger.warning(f"‚ö†Ô∏è Aucun prix disponible pour {symbol}")
            return None, None
        
        # Retourner le meilleur prix (le plus bas pour achat)
        best_broker = min(prices, key=prices.get)
        best_price = prices[best_broker]
        
        logger.info(f"üèÜ Meilleur prix {symbol}: {best_broker} √† ${best_price:.2f}")
        return best_broker, best_price
    
    def execute_trade(self, symbol: str, action: str, quantity: int) -> bool:
        """Ex√©cuter trade sur le meilleur broker disponible"""
        logger.info(f"üöÄ Ex√©cution {action} {quantity} {symbol}")
        
        # Essayer d'abord le broker actif
        active_broker = self.brokers.get(self.active_broker)
        if active_broker and self.connection_status.get(self.active_broker, False):
            try:
                success = active_broker.execute_trade(symbol, action, quantity)
                if success:
                    logger.info(f"‚úÖ Trade ex√©cut√© via {self.active_broker}")
                    return True
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur broker actif: {e}")
        
        # Fallback sur le premier broker disponible
        for name, broker in self.brokers.items():
            if self.connection_status.get(name, False) and name != self.active_broker:
                try:
                    success = broker.execute_trade(symbol, action, quantity)
                    if success:
                        logger.info(f"‚úÖ Trade ex√©cut√© via {name} (fallback)")
                        return True
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erreur fallback {name}: {e}")
                    continue
        
        logger.error(f"‚ùå Aucun broker disponible pour ex√©cuter le trade")
        return False
    
    def get_broker_status(self) -> Dict[str, bool]:
        """Retourner le statut de tous les brokers"""
        return self.connection_status.copy()
    
    def set_active_broker(self, broker_name: str):
        """D√©finir le broker actif par d√©faut"""
        if broker_name in self.brokers:
            self.active_broker = broker_name
            logger.info(f"üéØ Broker actif chang√©: {broker_name}")
        else:
            logger.warning(f"‚ö†Ô∏è Broker inconnu: {broker_name}")
    
    def get_available_brokers(self) -> List[str]:
        """Retourner la liste des brokers connect√©s"""
        return [name for name, status in self.connection_status.items() if status]

def main():
    """Test du syst√®me multi-broker"""
    print("üöÄ" + "="*80 + "üöÄ")
    print("   üî• MULTI-BROKER MANAGER - DIVERSIFICATION G√âOGRAPHIQUE")
    print("="*84)
    print("   ‚úÖ Yahoo Finance (gratuit)")
    print("   ‚úÖ Interactive Brokers (local)")
    print("   ‚úÖ Alpaca (paper trading)")
    print("   üéØ Objectif: +15-25% diversification")
    print("üöÄ" + "="*80 + "üöÄ")
    
    # Initialiser le gestionnaire
    manager = MultiBrokerManager()
    
    # Connecter les brokers
    print("\nüîå Connexion aux brokers...")
    manager.connect_brokers()
    
    # Afficher le statut
    print("\nüìä Statut des brokers:")
    status = manager.get_broker_status()
    for name, connected in status.items():
        status_icon = "‚úÖ" if connected else "‚ùå"
        print(f"   {status_icon} {name}: {'Connect√©' if connected else 'Non connect√©'}")
    
    # Test de r√©cup√©ration de prix
    test_symbols = ["AAPL", "MSFT", "GOOGL"]
    
    print(f"\nüìä Test r√©cup√©ration prix:")
    for symbol in test_symbols:
        best_broker, best_price = manager.get_best_price(symbol)
        if best_broker and best_price:
            print(f"   {symbol}: {best_broker} √† ${best_price:.2f}")
        else:
            print(f"   {symbol}: ‚ùå Prix non disponible")
    
    # Test d'ex√©cution de trade
    print(f"\nüöÄ Test ex√©cution trade:")
    success = manager.execute_trade("AAPL", "BUY", 1)
    if success:
        print("   ‚úÖ Trade simul√© r√©ussi")
    else:
        print("   ‚ùå Trade simul√© √©chou√©")
    
    print("\n‚úÖ Test multi-broker termin√©!")

if __name__ == "__main__":
    main()
