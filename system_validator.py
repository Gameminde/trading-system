"""
üß™ SYSTEM VALIDATOR - VALIDATION DES CORRECTIONS CRITIQUES
‚úÖ Test Transformer predictions r√©alistes
‚úÖ Test donn√©es r√©elles vs hardcod√©es
‚úÖ Test logique RL coh√©rente
‚úÖ Test donn√©es historiques vraies
‚úÖ Validation compl√®te du syst√®me
"""

import sys
import os
import time
import logging
import numpy as np
import pandas as pd
from datetime import datetime
from typing import Dict, List, Tuple

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
logger = logging.getLogger("SYSTEM_VALIDATOR")

class SystemValidator:
    """Validateur pour toutes les corrections critiques"""
    
    def __init__(self):
        self.test_results = {}
        self.critical_errors = []
        
    def validate_all_corrections(self) -> bool:
        """Valider que toutes les corrections fonctionnent"""
        logger.info("üß™ Validation des corrections critiques...")
        
        tests = [
            ("Transformer Predictions R√©alistes", self.test_transformer_realistic_predictions),
            ("Donn√©es R√©elles vs Hardcod√©es", self.test_real_vs_fake_data),
            ("Logique RL Coh√©rente", self.test_rl_logic_correctness),
            ("Donn√©es Historiques Vraies", self.test_real_historical_data),
            ("Validation Compl√®te Syst√®me", self.test_complete_system)
        ]
        
        all_passed = True
        
        for test_name, test_func in tests:
            logger.info(f"\n{'='*20} {test_name} {'='*20}")
            try:
                success = test_func()
                self.test_results[test_name] = success
                if success:
                    logger.info(f"‚úÖ {test_name}: R√âUSSI")
                else:
                    logger.error(f"‚ùå {test_name}: √âCHOU√â")
                    all_passed = False
            except Exception as e:
                logger.error(f"üí• {test_name}: ERREUR CRITIQUE - {e}")
                self.test_results[test_name] = False
                self.critical_errors.append(f"{test_name}: {e}")
                all_passed = False
        
        if all_passed:
            logger.info("‚úÖ Toutes les corrections valid√©es avec succ√®s")
        else:
            logger.error("‚ùå Certaines corrections ont √©chou√©")
            for error in self.critical_errors:
                logger.error(f"   üí• {error}")
        
        return all_passed
        
    def test_transformer_realistic_predictions(self) -> bool:
        """Tester que Transformer donne prix r√©alistes"""
        try:
            logger.info("üîÆ Test pr√©dictions Transformer...")
            
            # Importer le Transformer corrig√©
            from transformer_predictor import PricePredictor
            
            # Cr√©er donn√©es de test r√©alistes
            test_data = pd.DataFrame({
                'open': [100.0, 101.0, 99.0, 100.5, 102.0],
                'high': [102.0, 103.0, 100.0, 101.5, 103.0],
                'low': [99.0, 100.0, 98.0, 99.5, 101.0],
                'close': [100.0, 101.0, 99.0, 100.5, 102.0],
                'volume': [1000000] * 5,
                'rsi': [50.0, 55.0, 45.0, 52.0, 58.0],
                'macd': [0.0, 0.1, -0.1, 0.05, 0.15]
            })
            
            # Cr√©er et entra√Æner le mod√®le
            predictor = PricePredictor(sequence_length=3)
            predictor.train_model(test_data, epochs=10)
            
            # Tester pr√©diction
            predicted_price = predictor.predict_next_price(test_data)
            
            if predicted_price is None:
                logger.error("‚ùå Pr√©diction √©chou√©e")
                return False
            
            current_price = test_data['close'].iloc[-1]
            price_change = abs(predicted_price - current_price) / current_price
            
            logger.info(f"üìä Prix actuel: ${current_price:.2f}")
            logger.info(f"üîÆ Prix pr√©dit: ${predicted_price:.2f}")
            logger.info(f"üìà Changement: {price_change:.1%}")
            
            # V√©rifier que la pr√©diction est r√©aliste (¬±50% max)
            if price_change > 0.50:
                logger.error(f"‚ùå Pr√©diction trop extr√™me: {price_change:.1%}")
                return False
            
            # V√©rifier que le prix n'est pas aberrant
            if predicted_price <= 0 or predicted_price > current_price * 10:
                logger.error(f"‚ùå Prix aberrant: ${predicted_price:.2f}")
                return False
            
            logger.info("‚úÖ Pr√©dictions Transformer r√©alistes")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Test Transformer √©chou√©: {e}")
            return False
    
    def test_real_vs_fake_data(self) -> bool:
        """Tester que donn√©es sont r√©elles, pas hardcod√©es"""
        try:
            logger.info("üìä Test donn√©es r√©elles vs hardcod√©es...")
            
            # Importer le calculateur d'indicateurs r√©els
            from real_indicators_calculator import RealIndicatorsCalculator
            
            calculator = RealIndicatorsCalculator()
            
            # Tester avec plusieurs symboles
            symbols = ['AAPL', 'MSFT', 'GOOGL']
            all_real = True
            
            for symbol in symbols:
                data = calculator.get_real_market_data(symbol)
                if not data:
                    logger.error(f"‚ùå Impossible r√©cup√©rer donn√©es {symbol}")
                    all_real = False
                    continue
                
                logger.info(f"üìä {symbol}: Prix=${data['price']:.2f}, RSI={data['rsi']:.1f}, MACD={data['macd']:.4f}")
                
                # V√©rifier que RSI n'est pas toujours 50.0
                if data['rsi'] == 50.0 and data['source'] == 'yfinance_real':
                    logger.warning(f"‚ö†Ô∏è RSI suspect pour {symbol}: {data['rsi']}")
                
                # V√©rifier que MACD n'est pas toujours 0.0
                if data['macd'] == 0.0 and data['source'] == 'yfinance_real':
                    logger.warning(f"‚ö†Ô∏è MACD suspect pour {symbol}: {data['macd']}")
                
                # V√©rifier que le prix est r√©aliste
                if data['price'] <= 0 or data['price'] > 1000000:
                    logger.error(f"‚ùå Prix invalide {symbol}: ${data['price']:.2f}")
                    all_real = False
                
                # V√©rifier que la source n'est pas fallback
                if data['source'] == 'fallback':
                    logger.warning(f"‚ö†Ô∏è Fallback utilis√© pour {symbol}")
            
            if all_real:
                logger.info("‚úÖ Donn√©es r√©elles valid√©es")
                return True
            else:
                logger.error("‚ùå Certaines donn√©es sont invalides")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Test donn√©es r√©elles √©chou√©: {e}")
            return False
    
    def test_rl_logic_correctness(self) -> bool:
        """Tester logique RL balance/positions"""
        try:
            logger.info("ü§ñ Test logique RL...")
            
            # Importer l'environnement RL corrig√©
            from rl_trading_agent import TradingEnvironment
            
            # Cr√©er donn√©es de test
            test_data = pd.DataFrame({
                'close': [100.0, 101.0, 99.0, 100.5, 102.0],
                'rsi': [50.0, 55.0, 45.0, 52.0, 58.0],
                'macd': [0.0, 0.1, -0.1, 0.05, 0.15],
                'volume': [1000000] * 5
            })
            
            # Cr√©er environnement
            env = TradingEnvironment(test_data, initial_balance=10000)
            
            # Test 1: Achat
            obs, reward, done, truncated, info = env.step(1)  # BUY
            logger.info(f"üìä Apr√®s BUY: Balance=${env.balance:.2f}, Actions={env.shares}")
            
            # V√©rifier coh√©rence
            expected_balance = 10000 - (env.shares * 100.0)  # Prix d'achat
            if abs(env.balance - expected_balance) > 0.01:
                logger.error(f"‚ùå Balance incoh√©rente apr√®s BUY: {env.balance} vs {expected_balance}")
                return False
            
            # Test 2: Vente
            obs, reward, done, truncated, info = env.step(2)  # SELL
            logger.info(f"üìä Apr√®s SELL: Balance=${env.balance:.2f}, Actions={env.shares}")
            
            # V√©rifier que toutes les actions ont √©t√© vendues
            if env.shares != 0:
                logger.error(f"‚ùå Actions non vendues: {env.shares}")
                return False
            
            # V√©rifier conservation du capital (avec profit/perte)
            portfolio_value = env.balance
            logger.info(f"üìä Valeur finale portfolio: ${portfolio_value:.2f}")
            
            logger.info("‚úÖ Logique RL coh√©rente")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Test RL √©chou√©: {e}")
            return False
    
    def test_real_historical_data(self) -> bool:
        """Tester donn√©es historiques vraies"""
        try:
            logger.info("üìà Test donn√©es historiques vraies...")
            
            # Importer l'agent int√©gr√©
            from INTEGRATED_TRADING_SYSTEM import IntegratedTradingAgent, IntegratedTradingConfig
            
            config = IntegratedTradingConfig(enable_rl=True, enable_transformer=True)
            agent = IntegratedTradingAgent(config)
            
            # R√©cup√©rer vraies donn√©es historiques
            real_data = agent._get_real_historical_data_for_training("SPY", "1y")
            
            if real_data is None or len(real_data) < 100:
                logger.error("‚ùå Donn√©es historiques insuffisantes")
                return False
            
            logger.info(f"üìä Donn√©es historiques: {len(real_data)} p√©riodes")
            logger.info(f"üìä Colonnes: {list(real_data.columns)}")
            
            # V√©rifier que ce ne sont pas des donn√©es np.random
            if 'open' in real_data.columns:
                open_prices = real_data['open'].values
                if len(set(open_prices)) < 10:  # Si trop peu de valeurs uniques
                    logger.error("‚ùå Donn√©es suspectes (trop peu de variations)")
                    return False
            
            # V√©rifier indicateurs techniques
            if 'rsi' in real_data.columns:
                rsi_values = real_data['rsi'].dropna()
                if len(rsi_values) > 0:
                    rsi_range = (rsi_values.min(), rsi_values.max())
                    logger.info(f"üìä RSI range: {rsi_range[0]:.1f} - {rsi_range[1]:.1f}")
                    
                    # V√©rifier que RSI n'est pas toujours 50.0
                    if rsi_range[0] == rsi_range[1] == 50.0:
                        logger.error("‚ùå RSI toujours 50.0 (donn√©es suspectes)")
                        return False
            
            logger.info("‚úÖ Donn√©es historiques vraies valid√©es")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Test donn√©es historiques √©chou√©: {e}")
            return False
    
    def test_complete_system(self) -> bool:
        """Test complet du syst√®me int√©gr√©"""
        try:
            logger.info("üöÄ Test complet du syst√®me...")
            
            # Importer tous les composants
            from INTEGRATED_TRADING_SYSTEM import IntegratedTradingAgent, IntegratedTradingConfig
            from real_indicators_calculator import RealIndicatorsCalculator
            
            # Configuration
            config = IntegratedTradingConfig(
                enable_rl=True,
                enable_multi_broker=True,
                enable_transformer=True
            )
            
            # Cr√©er agent
            agent = IntegratedTradingAgent(config)
            
            # Test initialisation
            agent.initialize_system()
            
            # Test r√©cup√©ration donn√©es march√©
            symbols = ['AAPL', 'MSFT']
            for symbol in symbols:
                market_data = agent._get_market_data(symbol)
                if not market_data:
                    logger.error(f"‚ùå Impossible r√©cup√©rer donn√©es {symbol}")
                    return False
                
                logger.info(f"üìä {symbol}: {market_data['source']}")
            
            logger.info("‚úÖ Syst√®me complet valid√©")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Test syst√®me complet √©chou√©: {e}")
            return False
    
    def generate_validation_report(self) -> str:
        """G√©n√©rer rapport de validation"""
        report = []
        report.append("# üß™ RAPPORT DE VALIDATION DES CORRECTIONS CRITIQUES")
        report.append("")
        report.append(f"üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("")
        
        # R√©sum√© des tests
        total_tests = len(self.test_results)
        passed_tests = sum(1 for result in self.test_results.values() if result)
        failed_tests = total_tests - passed_tests
        
        report.append("## üìä R√âSUM√â DES TESTS")
        report.append(f"- **Total:** {total_tests}")
        report.append(f"- **R√©ussis:** {passed_tests}")
        report.append(f"- **√âchou√©s:** {failed_tests}")
        report.append(f"- **Taux de succ√®s:** {(passed_tests/total_tests)*100:.1f}%")
        report.append("")
        
        # D√©tail des tests
        report.append("## üß™ D√âTAIL DES TESTS")
        for test_name, result in self.test_results.items():
            status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHOU√â"
            report.append(f"- **{test_name}:** {status}")
        report.append("")
        
        # Erreurs critiques
        if self.critical_errors:
            report.append("## üö® ERREURS CRITIQUES")
            for error in self.critical_errors:
                report.append(f"- {error}")
            report.append("")
        
        # Conclusion
        if failed_tests == 0:
            report.append("## üéâ CONCLUSION")
            report.append("**‚úÖ TOUTES LES CORRECTIONS VALID√âES AVEC SUCC√àS!**")
            report.append("")
            report.append("Le syst√®me est maintenant **PRODUCTION-READY** et pr√™t pour d√©ploiement avec capital r√©el.")
        else:
            report.append("## ‚ö†Ô∏è CONCLUSION")
            report.append(f"**‚ùå {failed_tests} CORRECTION(S) ONT √âCHOU√â**")
            report.append("")
            report.append("Des corrections suppl√©mentaires sont n√©cessaires avant le d√©ploiement en production.")
        
        return "\n".join(report)

def main():
    """Point d'entr√©e principal"""
    print("üöÄ" + "="*80 + "üöÄ")
    print("   üî• VALIDATION DES CORRECTIONS CRITIQUES")
    print("="*84)
    print("   üéØ Objectif: V√©rifier que le syst√®me est PRODUCTION-READY")
    print("üöÄ" + "="*80 + "üöÄ")
    
    try:
        validator = SystemValidator()
        success = validator.validate_all_corrections()
        
        # G√©n√©rer rapport
        report = validator.generate_validation_report()
        
        # Sauvegarder rapport
        with open("VALIDATION_REPORT.md", "w", encoding="utf-8") as f:
            f.write(report)
        
        print("\n" + "="*84)
        print("üìä RAPPORT DE VALIDATION G√âN√âR√â: VALIDATION_REPORT.md")
        print("="*84)
        
        if success:
            print("üèÜ TOUS LES TESTS R√âUSSIS!")
            print("üéâ Le syst√®me est maintenant PRODUCTION-READY!")
            print("üöÄ Pr√™t pour d√©ploiement avec capital r√©el!")
            sys.exit(0)
        else:
            print("‚ö†Ô∏è  Certains tests ont √©chou√©")
            print("üîß Des corrections suppl√©mentaires sont n√©cessaires")
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Validation interrompue par l'utilisateur")
        sys.exit(1)
    except Exception as e:
        print(f"\nüí• Erreur critique lors de la validation: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
